1、为什么需要锁（并发控制）
  在多用户环境中，在同一时间可能会有多个用户更新相同的记录，这会产生冲突。这就是著名的并发问题
2、典型的冲突：
  2.1 丢失更新；一个事务覆盖了其他事务的更新结果
  2.2 脏读：当一个事务读取其他完成一半的记录时，就会发生脏读
3、并发控制机制：
  悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
  乐观锁：假设不会发生并发冲突，只是在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读问题
4、乐观锁和悲观锁
   悲观锁：每次拿到数据，都会对数据加锁，其他人想要拿到数据，就会block
           传统数据库里面就有很多的这样的锁机制：行级锁，表级锁，读锁，写锁等，都是在做操作之前上锁。
   乐观锁：每次拿到数据，都不会上锁，但是在做更新操作时候会判断，此期间别人有没有对这个数据做更新操作，可以使用版本号等机制。
           乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供类似write_condition机制的，都是乐观锁
           

两种锁的优缺点：
    乐观锁用于写比较少或者是更新冲突很少发生的情况，减少系统开销，提高系统的吞吐量
    悲观锁用于防止数据更新冲突，或者是乐观锁导致的频繁的retry

乐观锁的应用
   1、使用自增长的整数来表示数据版本号，更新一次+1，每次更新对附带版本号
   2、使用时间戳来实现，原理一致，更新时对比时间戳，成功后写入时间戳
悲观锁的应用
   1、数据库锁机制
   2、在实际的生产环境里面，如果并发量不大，且不允许脏读，可以使用悲观锁解决并发问题
      如果系统的并发非常大，悲观锁会带来很大的性能问题
      悲观锁对长事务影响很大，并发性不好
    3、悲观锁大多数情况下，依赖于数据库锁机制实现
   典型的悲观锁：select for update ,不满足条件就会锁住整张表
   悲观锁一般适用于短事务比较多
   
   乐观锁一般是通系统实现，业务逻辑来控制，
   乐观锁机制往往是基于系统中的数据存储逻辑来实现的
           
           
           
           
           
           
           
           