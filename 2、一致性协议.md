2阶段提交 2PC
为了使基于分布式系统架构下的所有节点在进行分布式事务处理过程中能够保持原子性和一致性而设计的一种算法
利用该协议方便的完成分布式事务的参与者的协调，同意决定事务的提交或回滚，从而有效的保证分布式数据的一致性

协议说明：
   1、阶段一：提交事务请求
      1.1 事务询问
          协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应
      1.2 执行事务
          各参与者节点执行事务操作，并将Undo和Redo信息写入事务日志中
      1.3 各参与者像协调者反馈事务询问的响应
          如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行
          如果参与者没有成功执行事务操作，那么就反馈给协调者No响应，表示事务不可以执行

   2、阶段二：执行事务提交
      2.1 执行事务提交
         2.1.1 发送提交请求
               协调者向参与者发送Commit请求
         2.1.2 事务提交
               参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源
         2.1.3 反馈事务提交结果
               参与者在完成事务提交之后，想协调者发送Ack消息
         2.1.4 完成事务
               协调者接收到所有参与者反馈的Ack消息后，完成事务

      2.2 中断事务

         2.2.1 发送回滚请求
               协调者向所有的参与者节点发送Rollback请求
         2.2.2 事务回滚
               参与者在接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚操作后释放在事务执行期间占用的资源
         2.2.3 反馈事务回滚结果
               参与者在完成事务回滚之后，想协调者发送Ack信息
         2.2.4 中断事务
               协调者接收到所有参与者反馈的Ack信息后，完成事务中断

   优缺点：
      优点：原理简单、实现方便
      缺点：同步阻塞、单点问题、数据不一致、太过保守
      同步阻塞：在二阶段提交的执行过程中，所有的参与该事务操作的逻辑都处于阻塞状态，也就是说各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作
      单点问题：在整个执行过程中，一旦协调者出现故障，那么真个二阶段提交流程将无法运行；如果在阶段二中出现故障，那么其他参与者将会一直处于锁定事务资源的状态，而无法继续完成事务操作
      数据不一致：阶段二，执行事务提交的时候，当协调者向所有的参与者发送Commit请求后，发生了局部网络异常或者协调者在尚未发送完Commit请求之前发生了崩溃，导致只有部分参与者收到了Commit请求
      容错性较差：二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致生个事务的失败。eg:如果协调者在指示参与者进行事务提交询问的过程中，
               参与者出现故障而导致协调者始终无法获取所有参与者的响应信息的话，这时协调者只能通过自身的超时机制来判断是否需要中断事务


3阶段提交 3PC
   说明：3阶段提交是2PC的改进版，将二阶段的事务提交协议的"提交事务请求"过程一分为二，形成CanCommit，PreCommit和DoCommit三个阶段组成的事务处理协议
   阶段一：CanCommit
      1.1 事务询问
          协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交，并且开始等待各个参与者的响应
      1.2 各个参与者向协调者反馈事务询问的响应
          参与者在接收到来自协调者的canCommit请求后，正常情况下，如果自身认为可以顺利的执行任务，那么反馈yes，并且进入预备状态，否则反馈No
   阶段二：PreCommit
      2.1 执行事务的预提交
          如果协调者从所有的参与者获得的响应都是yes，那么执行事务预提交
          2.1.1 发送预提交请求
                协调者想所有的参与者节点发送preCommit的请求，并且进入Prepared阶段
          2.1.2 事务预提交
                参与者接收到preCommit的请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中
          2.1.3 参与者想协调者反馈事务执行的响应
                如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同事等待最终的指令：提交（commit）或中指（abort）
      2.2 中断事务
          加入任何一个参与者向协调者反馈了No，或者在等待超时之后，协调者还无法接收到所有参与者的响应，那么就中断事务
          2.2.1 发送中断请求
                协调者向所有参与者发送abort请求
          2.2.2 中断事务
                无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务

   阶段三：DoCommit
      3.1 执行提交
          3.1.1 发送提交请求
                进入这一阶段，假设协调者处于正常工作状态，他接受了来自所有参与者的ack响应，那么他将从预提交状态转化为提交状态，并且向所有的参与者发送doCommit请求
          3.1.2 事务提交
                参与者接收到doCommit请求后，会正式执行事务提交操作，并且自完成提交之后，释放整个事务执行期间占用的事务资源
          3.1.3 反馈事务提交的结果
                参与者在完成事务提交之后，想协调者发送Ack消息
          3.1.4 完成事务
                协调者接收到所有参与者反馈的Ack消息后，完成事务

      3.2 中断事务
          3.2.1 发送中断请求
                协调者向所有参与者发送abort请求
          3.2.2 事务回滚
                参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息，来执行事务的回滚操作，并在完成回滚后释放整个事务执行期间占用的资源
          3.2.3 反馈事务回滚结果
                参与者在完成事务回滚之后，想协调者发送Ack消息
          3.2.4 中断事务
                协调者接收到所有参与者反馈的Ack消息后中断事务

   注意：一旦进入三阶段，可能会出现以下两种故障：
        1、协调者出现问题
        2、协调者和参与者之间出现网络故障
        无论哪一种情况出现，最终都会导致参与者无法及时接受来自协调者的doCommit或者是abort请求，正对这样的情况，参与者都会在等待超时后继续执行事务提交

   优点：1、降低参与者的阻塞范围，并且在出现单点故障后。继续达成一致
   缺点：1、数据不一致：参与者在接收到preCommit消息后，出现网络分区，此时协调者与参与者无法进行正常的网络通信，在这种情况下参与者依然会继续进行事务的提交，必然会出现数据的不一致
        2、容错性较差：如果出现网络分区，或者单个协调者响应No的时候，整个事务执行就不会成功

Paxos 算法
