2阶段提交 2PC
为了使基于分布式系统架构下的所有节点在进行分布式事务处理过程中能够保持原子性和一致性而设计的一种算法
利用该协议方便的完成分布式事务的参与者的协调，同意决定事务的提交或回滚，从而有效的保证分布式数据的一致性

协议说明：
   1、阶段一：提交事务请求
      1.1 事务询问
          协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应
      1.2 执行事务
          各参与者节点执行事务操作，并将Undo和Redo信息写入事务日志中
      1.3 各参与者像协调者反馈事务询问的响应
          如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行
          如果参与者没有成功执行事务操作，那么就反馈给协调者No响应，表示事务不可以执行

   2、阶段二：执行事务提交
      2.1 执行事务提交
         2.1.1 发送提交请求
               协调者向参与者发送Commit请求
         2.1.2 事务提交
               参与者接收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源
         2.1.3 反馈事务提交结果
               参与者在完成事务提交之后，想协调者发送Ack消息
         2.1.4 完成事务
               协调者接收到所有参与者反馈的Ack消息后，完成事务

      2.2 中断事务

         2.2.1 发送回滚请求
               协调者向所有的参与者节点发送Rollback请求
         2.2.2 事务回滚
               参与者在接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务回滚操作，并在完成回滚操作后释放在事务执行期间占用的资源
         2.2.3 反馈事务回滚结果
               参与者在完成事务回滚之后，想协调者发送Ack信息
         2.2.4 中断事务
               协调者接收到所有参与者反馈的Ack信息后，完成事务中断

   优缺点：
      优点：原理简单、实现方便
      缺点：同步阻塞、单点问题、数据不一致、太过保守
      同步阻塞：在二阶段提交的执行过程中，所有的参与该事务操作的逻辑都处于阻塞状态，也就是说各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作
      单点问题：在整个执行过程中，一旦协调者出现故障，那么真个二阶段提交流程将无法运行；如果在阶段二中出现故障，那么其他参与者将会一直处于锁定事务资源的状态，而无法继续完成事务操作
      数据不一致：阶段二，执行事务提交的时候，当协调者向所有的参与者发送Commit请求后，发生了局部网络异常或者协调者在尚未发送完Commit请求之前发生了崩溃，导致只有部分参与者收到了Commit请求
      容错性较差：二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致生个事务的失败。eg:如果协调者在指示参与者进行事务提交询问的过程中，
               参与者出现故障而导致协调者始终无法获取所有参与者的响应信息的话，这时协调者只能通过自身的超时机制来判断是否需要中断事务


3阶段提交 3PC
   说明：3阶段提交是2PC的改进版，将二阶段的事务提交协议的"提交事务请求"过程一分为二，形成CanCommit，PreCommit和DoCommit三个阶段组成的事务处理协议
   阶段一：CanCommit
      1.1 事务询问
          协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交，并且开始等待各个参与者的响应
      1.2 各个参与者向协调者反馈事务询问的响应
          参与者在接收到来自协调者的canCommit请求后，正常情况下，如果自身认为可以顺利的执行任务，那么反馈yes，并且进入预备状态，否则反馈No
   阶段二：PreCommit
      2.1 执行事务的预提交
          如果协调者从所有的参与者获得的响应都是yes，那么执行事务预提交
          2.1.1 发送预提交请求
                协调者想所有的参与者节点发送preCommit的请求，并且进入Prepared阶段
          2.1.2 事务预提交
                参与者接收到preCommit的请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中
          2.1.3 参与者想协调者反馈事务执行的响应
                如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同事等待最终的指令：提交（commit）或中指（abort）
      2.2 中断事务
          加入任何一个参与者向协调者反馈了No，或者在等待超时之后，协调者还无法接收到所有参与者的响应，那么就中断事务
          2.2.1 发送中断请求
                协调者向所有参与者发送abort请求
          2.2.2 中断事务
                无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时时，参与者都会中断事务

   阶段三：DoCommit
      3.1 执行提交
          3.1.1 发送提交请求
                进入这一阶段，假设协调者处于正常工作状态，他接受了来自所有参与者的ack响应，那么他将从预提交状态转化为提交状态，并且向所有的参与者发送doCommit请求
          3.1.2 事务提交
                参与者接收到doCommit请求后，会正式执行事务提交操作，并且自完成提交之后，释放整个事务执行期间占用的事务资源
          3.1.3 反馈事务提交的结果
                参与者在完成事务提交之后，想协调者发送Ack消息
          3.1.4 完成事务
                协调者接收到所有参与者反馈的Ack消息后，完成事务

      3.2 中断事务
          3.2.1 发送中断请求
                协调者向所有参与者发送abort请求
          3.2.2 事务回滚
                参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息，来执行事务的回滚操作，并在完成回滚后释放整个事务执行期间占用的资源
          3.2.3 反馈事务回滚结果
                参与者在完成事务回滚之后，想协调者发送Ack消息
          3.2.4 中断事务
                协调者接收到所有参与者反馈的Ack消息后中断事务

   注意：一旦进入三阶段，可能会出现以下两种故障：
        1、协调者出现问题
        2、协调者和参与者之间出现网络故障
        无论哪一种情况出现，最终都会导致参与者无法及时接受来自协调者的doCommit或者是abort请求，正对这样的情况，参与者都会在等待超时后继续执行事务提交

   优点：1、降低参与者的阻塞范围，并且在出现单点故障后。继续达成一致
   缺点：1、数据不一致：参与者在接收到preCommit消息后，出现网络分区，此时协调者与参与者无法进行正常的网络通信，在这种情况下参与者依然会继续进行事务的提交，必然会出现数据的不一致
        2、容错性较差：如果出现网络分区，或者单个协调者响应No的时候，整个事务执行就不会成功

Paxos 算法
   1、常见的分布式系统中总会发生诸如：机器宕机、网络异常等情况，
      Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中快速并正确的在集群内部对某个数据达成一致，
      并且保证无论发生任何异常都不会破坏整个系统的一致性
   2、从理论上来讲，在分布式计算领域，试图在异步系统和不可靠的信道上达到一致的状态是不可能的，因此在对一致性研究的过程中，都往往假设信道是可靠的
   2.1 大多数系统在同一个局域网中，消息被篡改的可能性很小
   2.2 因为硬件或者网络原因造成的消息不完整，通过简单的校验算法即可避免
   实践过程中，也假设消息是完整的，没有篡改的
   
Paxos 算法详解
   1、问题描述：
      假设有一组可以提出提案的进程集合，那么对于一致性算法来说，需要保证以下几点
      1、在这些被提出的提案中只有一个会被选定
      2、如果没有提案被提出，那就不会有被选定的提案
      3、当一个提案被选定后，进程应该可以获取被选定的提案信息
      
   2、对于一致性来说，安全性要求如下：
      1、只有被提出的提案才能被选定
      2、只能有一个值被选定（特别注意哦，一个值被选定）
      3、如果某个进程认为某个提案被选定，那么这个提案必须是真的被选定的那个
      
   3、Paxos算法的目标就是要保证最终有一个提案会被选定，当提案被选定后，进程最终能够获取被选定的提案
   
   4、算法描述：
      三种参与角色：Proposer、Acceptor和Learner来表示
      假设参与者之间可以通过收发消息来进行通信，那么：
         1、每个参与者以任意的速度执行，可能会因为出错而停止，可能会重启。
            同时，即使一个提案被选定后，所有参与者都有可能失败或者重启，因此除非那些失败或者重启的参与者能够记录某些信息，否则将无法确定最终值
         2、消息在传输的过程中可能会出现不可预知的延迟，可能会丢失、重复，但是消息不会被损坏，即消息内容不会被篡改
         
      推到过程：
         结果：最终只有一个提案被选定
         第一层：
             方式：多个Proposer ,一个Acceptor, Proposer只能够发送提高给Acceptor，Acceptor选择他第一个接收到的提案作为被选定的提案
             缺点：单点问题
         第二层：
             多个Proposer,多个Acceptor，
             Proposer向一个Acceptor集合发送提案，同样集群中的每一个Acceptor都有可能批准该提案，当有足够多的Acceptor批准这个提案的时候，我们就可以认为该提案被选定
             足够多：集合大的可以包含Acceptor集合中的大多数成员，任意两个包含大多数Acceptor的子集至少有一个公共成员
             因此我们另外规定：每一个Acceptor只能批准一个提案
        
        1、如果我们希望在只有一个提案被提出的情况下，仍然可以选出一个提案，那么就暗示如下需求：
             P1: 一个Acceptor必须批准它收到的第一个提案
             新的问题：没有一个提案被多数Accptor批准
               P1，P2、P3、P4 提出4个不同提案，分别发送给A1、A2、A3、A4四个Acceptor，那么就会有4个不同的提案被选定
             新的需求R1：一个提案被选定，需要被多数的Acceptor批准
             
        推导出：
             R1的需求，暗示着：一个Acceptor可以批准不止一个提案
             解决方案：试用编号+值的方式，[编号，Value]来表示提案（提案与值得概念不一样了）
             要求：多个提案可以被选定，但是被选定的提案的值都具有相同的Value值
             
             描述：P2：如果编号为M0、Value为V0的提案[M0,V0]被选定了，那么所有比编号M0更高的，且被选定的提案，其Value值必须为V0
                  因为提案编号的大小关系是全序关系的，所以条件P2就保证了只有一个Value值被选定这一关键的安全性属性
                  
         全序关系特征：         
                设集合X上有一全序关系，如果我们把这种关系用 ≤ 表述，则下列陈述对于 X 中的所有 a, b 和 c 成立：
                如果 a ≤ b 且 b ≤ a 则 a = b (反对称性)
                如果 a ≤ b 且 b ≤ c 则 a ≤ c (传递性)
                a ≤ b 或 b ≤ a (完全性)
            
            
             一个被限定的提案，首先必须被一个Acceptor批准，
             那么P2的换一种方式表述为：
                 P2a：如果编号为M0、Value值为V0的提案[M0，V0]被选定了，那么所有比编号M0更高的，且被Acceptor批准的提案，其Value值必须为V0
                 
               新的问题：[M0,V0]一个提案会在某一个Acceptor（A0）还没有收到任何提案的情况下被选中，而另外一个提案[M1,V1]被送达A0，那么[M1、V1]提案也会被选中（P1）
                        这样与P2a矛盾，
               为了同时满足P2a和P1，那么提出条件P2b
                 P2b：如果一个提案[M0,V0]被选定后，那么之后产生的任何编号更高的提案，其Value值都为V0
               
论证P2b成立
    假设某个提案[M0，V0]已经被选定，那么任何编号Mn>M0的提案，其Value值都是V0
    
    
P2c 条件：存在一个由超过半数的Acceptor组成的集合S，要么S中没有Acceptor批准过编号小于Mn的任何提案，要么S中的所有Acceptor批准的所有编号小于Mn的提案中，编号最大的那个提案的Vlaue值为Vn


Paxos 算法实现描述:
Propser生成提案：
   1、Proposer选择一个新的提案，编号Mn，然后想某一个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下的回应：
        1.1 向Proposer承诺，保证不再批准任何编号小于Mn的提案
        1.2 如果Acceptor已经批准过任何提案，那么向其Proposer反馈当前该Acceptor已经批准的编号小于Mn但为最大编号的那个提案
      我们将该请求成为编号为Mn的提案的Prepare请求
   2、如果Proposer收到来自半数以上的Acceptor的响应结果，那么它就可以产生编号为Mn，Value值为Vn的提案，这里的Vn是指所有响应中编号最大的提案的Value值
      如果响应中不包含任何的提案，那么此时的Vn值就可以由Proposer任意选择
   3、确定提案之后，Proposer会将该提案送给某个Acceptor集合，并期望获得它的批准，这个请求成为Acceptor请求
Acceptor批准提案
   1、Prepare 请求响应：Acceptor可以在任何时候响应一个Prepare请求
   2、Acceptor请求响应：在不违背Accept现有的承诺的前提下，可以任意的响应Accept请求
   （Acceptor请求逻辑定义：一个Acceptor只要尚未响应过任何编号大于Mn的Prepare请求，那么他就可以接受这个编号为Mn的提案）
算法优化：
   1、原则：尽可能的忽略Prepare请求：
         假设一个Acceptor收到了一个Mn的Prepare请求，此时该Acceptor已经对编号大于Mn的Prepare的请求做出了响应，
         因此它肯定不会批准任何新的编号为Mn的提案，那么很显然Acceptor没有必要对这个Prepare请求作出响应，于是Acceptor可以选择忽略这样的Prepare请求。
         同时Acceptor也可以忽略掉那些它已经批准过的提案的Prepared请求
      通过这个优化，每个Acceptor只需要记住他已经批准的提案的最大编号以及它已经作出Prepare请求响应的提案的最大编号，以便在出现故障节点的情况下也能保证P2c不变性
      而对于Proposer来说，只要他可以保证不会产生重复的具有相同编号的提案，那么就可以丢次任意的提案以及它所有的运行时的状态信息
      
算法陈述：
    阶段一：
       1、Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求
       2、如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acceptor已经响应的所有Prepare请求的编号，
          那么他就会将它已经批准过的最大编号的提案最为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案
    阶段二：
       1、如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对[Mn，Vn]提案的Accept请求给Acceptor。
          注意：Vn的值是Proposer收到的Prepare请求响应中编号最大的提案的Value值，如果响应中不包括任何提案，那么Vn就是任意值
       2、如果Acceptor收到这个针对[Mn,Vn]提案的Accept请求，只要该Acceptor尚未对编号大于Mn的Prepare请求作出响应，它就可以通过提案
提案获取：
    最终方案：
        每一个Acceptor将批准的提案发送给指定的Learner集合，该集合中的每一个Learner都可以在一个提案被选定后，通知所有其他的Learner。
        Learner集合中leaner的数量越多，可靠性越好，网络通信复杂度越高
        
缺点：
   可能造成死循环；
   


      
   
               
             
               
         
         
         
         
         
         
         
         
         
         
   